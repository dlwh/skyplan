%File: formatting-instruction.tex
\documentclass[letterpaper]{article}
\usepackage{aaai}
\usepackage{times}
\usepackage{helvet}
\usepackage{courier}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{amsthm}
\usepackage{natbib}

\theoremstyle{plain} \newtheorem{theorem}{Theorem} \newtheorem{proposition}{Proposition} \newtheorem{lemma}{Lemma}
\newtheorem*{corollary}{Corollary}  \newtheorem{claim}{Claim} 

\theoremstyle{definition} \newtheorem{definition}{Definition} \newtheorem{conjecture}{Conjecture} \newtheorem*{example}{Example} 

\theoremstyle{remark} \newtheorem*{remark}{Remark} \newtheorem*{note}{Note} \newtheorem{case}{Case}

\newcommand{\R}{\mathbb{R}}

\frenchspacing
\pdfinfo{
/Title (Faster Optimal Planning with Partial-Order Pruning)
/Subject (AAAI Publications)
/Author (Redacted)}
\setcounter{secnumdepth}{0}  
 \begin{document}
% The file aaai.sty is the style file for AAAI Press 
% proceedings, working notes, and technical reports.
%
\title{Faster Optimal Planning with Partial-Order Pruning}
%%\author{AAAI Press\\
%Association for the Advancement of Artificial Intelligence\\
%2275 East Bayshore Road, Suite 160\\
%Palo Alto, California 94303\\
%}
\author{}

\maketitle
\begin{abstract}
\begin{quote}
  When planning problems have many kinds of resources or high
  concurrency, each optimal state has exponentially many minor
  variants, some of which are "better" than others. Standard methods
  like A* cannot effectively exploit these minor relative differences,
  and therefore must explore many redundant, clearly suboptimal
  plans. We describe a new optimal search algorithm for planning
  that leverages a partial order relation between states. Under
  suitable conditions, states that are dominated by another with
  respect to this order can be pruned while provably maintaining
  optimality. We also describe a simple method for automatically
  discovering compatible partial orders in both serial and concurrent
  domains. In our experiments we find that more than 99\% of search
  states can be pruned in some domains.
\end{quote}
\end{abstract}

\section{Introduction}

Planning problems differ from other search problems in a number of
ways. One important distinction is that there are typically many
planning states that are ``similar'' along one or more dimensions.
For instance, in a job shop scheduling domain, one search state
might have the same number of widgets---but fewer sprockets---than
another. Assuming that more is always better and that the two states
can be reached in the same time, we can safely discard the former,
\textit{dominated} states, instead focusing our search on the better
state.

In this paper, we seek to formalize this notion, using Pareto
dominance to prune states that are strictly dominated by some other
states. More specifically, we give conditions under which we can
expand only those states in the \textit{skyline}, that is, states
that are not dominated by any another state. Our system, Skyplan,
is a refinement of Uniform Cost Search or A$^*$ that expands only
those states that are on the skyline.

The central idea underlying our approach is to define a partial
order relationship between states in the search space. This partial
order has an intuitive interpretation: one state dominates another
if it has no fewer ``good'' resources (e.g. jobshop outputs) than
another, no more ``bad'' resources (e.g. labor expended or time
taken), and it is better in one or more ways. 

In addition to proving the correctness of our approach, we also
show how to automatically infer such a partial order from a problem
specification such as PDDL.~\cite{ghallab1998pddl,fox2003pddl2}
This procedure is fairly intuitive: one simply needs to determine
which resources or propositions are uniformly good or bad, and---for 
domains with durative actions---which actions have uniformly
good or bad final effects.

In our experiments, we compare Skyplan to a similar implementation
of $A^*$ on several (XXX) job shop domains. In addition, we introduce
two new domains, based on the popular video game StarCraft. (XXX
we should credit evo chamber for one of them.) Skyplan performs
especially well in these scenarios, cutting the branching factor
by as much as 99\% compared to A$^*$.  Furthermore, we compare our
algorithm to a heuristic open source planner specifically engineered
to one of the two StarCraft domains.

\section{Skyplan}

\begin{figure}
  \caption{Pareto Optimality figure}
\end{figure}

We operate in the standard convention of planning as search within
a weighted directed graph.  A planning problem consists of a directed
graph $G$ with states $n$ consisting of planning states.  States are
linked by directed edges with an associated a cost function
$\mathrm{cost}(n_s,n_t) \in \mathbb R^+$.  There is also a privileged
initial state $s$, along with a set of goal states $F$.  Further
define $g(n)$ to be the minimum cost path from $s$ to any state $n$.
Our goal is to find a path from $s$ to some state $n_g \in F$ with
the lowest g cost.


\subsection{Partial Orders}

We will further assume that our graph is endowed with a partial order $\preceq$
that relates states $n$ to one another, with the intuitive semantics that
$n \preceq m$ if $n$ is no better than $m$ in any way. For example, in
our sprockets and widgets example, $n \prec m$ if $n$ has no more widgets and
no more sprockets than $m$ and if $g(n) \ge g(m)$. Strict dominance
holds if $m$ is in addition strictly better than $n$ in some way.

Our goal is to define an optimal search algorithm that can exploit
this partial order to reduce the search space by only expanding
states $n$ that are \textit{weakly Pareto optimal}, that is states
$n$ with $n \nprec n'$ for all states $n'$. For any set of states
$N$, we define the \textit{skyline} of that set as
$\textrm{skyline}(N)=\{n: \ne n' \in N: n \prec n'\}$. That is, the
skyline of a set is those states which are weakly Pareto optimal.
In subsequent sections, we will give a useful sufficient condition
under which we can exploit a partial order while preserving correctness
of optimal graph search algorithms.

We are not the first to suggest the use of Pareto optimality or
skyline queries in the context of planning. For example, the
non-optimal Metric-FF planner~\cite{hoffmann2003metric} employed a
more limited notion of dominance, requiring that all propositions
be the same between two states, the domain to be monotonically
``good'' in all resources, and for the dominating state to have no
fewer resources along any axis. Our notion of dominance is more
general, and we are able to find useful partial orders in more general
domains.

More recently, in another satsificing planner, \citet{roger2010more}
combined multiple heuristics by only expanding those states which
were currently Pareto optimal with respect to the current open set.
By contrast, we seek to \textit{prune} search states while still
maintaining optimality.

Still others have employed other notions of partial orders while
maintaining completeness and optimality. These methods largely fall
into a category known as ``partial order reduction techniques,''
from computer aided verification. These methods fall into two
categories: those that prune states and those that prune transitions.
The former class includes expansion cores \cite{chen09completeness,
xu11theory}, which select only ``relevant'' actions for any given
state. The latter consists of methods like commutativity
pruning~\cite{geffner2000admissible}, which prunes redundant
permutations of partial plans, and stratified
planning~\cite{chen2009stratified}, which identifies layers of the
planning problem and only considers actions appropriate to a given
layer. \citet{wehrle2012partial} recently showed that all of these
techniques are special cases of more general techniques from computer
aided verification, namely sleep sets~\cite{godefroid96partial} and
stubborn sets~\cite{valmari92stubborn}. These methods are largely
orthogonal to our approach. Indeed we use something not unlike
expansion cores in our system.


\subsection{Algorithm}

Skyplan is a fairly straightforward modifications of Uniform
Cost Search or A$^*$. For the sake of exposition, we focus on Uniform Cost
Search, though A$^*$ or any optimal graph search algorithm can
be modified in the same way.

Skyplan is defined in Algorithm \ref{alg:skyplan}. Essentially, we run Uniform Cost Search as normal, except that 
we only expand states that are not strictly dominated by another
state we've either expanded or enqueued for expansion. That is, we only expand nodes that are in the \textit{skyline}
of the nodes explored so far.

\begin{algorithm}
  \begin{algorithmic}[1]
    \Procedure{Skyplan}{XXX}
    \State Initialize $Open=\{\langle s,0\rangle\}$, $Closed=\{\}$, $Pruned=\{\}$
    \While{ $Open$ is not empty}
    \State Pop the minimum cost state $\mathbf{n} = \langle n,c\rangle\in Open$
      \State $n\rightarrow Closed$
      \If {$n\in F$} 
        \State \Return the path to $n$ following back pointers
      \EndIf
      \For {$n^\prime\in\mathrm{succ}(n)$} 
      \State $\mathbf{n^\prime} \gets \langle n^\prime,c+\mathrm{cost}(n,n^\prime)\rangle$
        \If {$\forall m \in Open \cup Closed. n^\prime \nprec m$}
        \State $\mathbf{n^\prime} \rightarrow Open$
        \EndIf
      \EndFor
    \EndWhile
  \EndProcedure
  \end{algorithmic}
\caption{Skyplan}
\label{alg:skyplan}
\end{algorithm}

\subsection{Compatibility}
\begin{figure}
  \caption{Compatible partial orders. Partial orders stay ahead.}
\end{figure}

Not just any partial order on states can be used to preserve optimality. As a perverse
example, we can define a partial order under which all states on the optimal path
are dominated by non-optimal states. Thus, we need to define a property
under which a partial order is \textit{compatible} with a search graph. While
a broad class of partial orders might work, we have identified a particular 
property that is especially applicable to planning problems:

\begin{definition}[Compatibility]
	\label{def-compatibility}
  A partial order $\prec$ is \textit{compatible} if for all states $n \preceq m$,
  \begin{enumerate}
    \item $g(n) \ge g(m)$, and 
    \item $\forall n' \in \mathrm{succ(n)}$ $\exists m' \in
      \mathrm{succ}(m')$ such that $n' \preceq m'$ and
      $cost(n,n') \ge cost(m, m')$, and
    \item If $n \in F$, then $m \in F$
  \end{enumerate}
\end{definition}
This recursive definition of compatibility essentially means that
if a state $n$ is dominated by a state $m$, then it must be the
case that $n$ is no cheaper than $m$ and that $m$'s successors
``stay ahead'' of $n$'s. Finally, $F$ must be closed with respect
to $\succeq$: every state that dominates a goal state must also be
a goal. It is worth mentioning that there is always a compatible
partial ordering: the trivial order with $n \npreceq m$ for all
states $n$ and $m$.

In planning problems, defining a compatible partial order is usually
quite easy, so long as cost functions are additive.  Actions are
often defined in terms of partial states with constant costs (e.g.\
time elapsed), and so compatibility is easily checked.  In the
sequel, we discuss a standard structure for these partial orders,
as well as how to automatically infer a partial order from the
specification of a planning problem.

\subsection{Analysis}

XXX

\begin{claim}{}\label{clm-complete}
   If $\preceq$ is a compatible partial order, Skyplan
is \emph{complete}.
\end{claim}
\begin{proof} Suppose otherwise, then all paths to all goals must
have been pruned. Consider one such path $p$ and let $n$ be the
state in $p$ that was pruned, and let $p_{n:}$ be the suffix of the
path starting from $n$. Let $m$ be a state with $m \succ n$ that was
not pruned.  By transitivity of $\preceq$, such a state must exist.
Then, from condition and (2) and (3) of compatibility, a simple
inductive argument shows that there must be an analogous path 
$p^\prime_{m:}$ ending in a goal state.

  XXX We should say something ensuring that no states in $p^\prime$ are pruned.
\end{proof}
  
\begin{claim}{}\label{clm-optimal}
   If $\preceq$ is a compatible partial order, Skyplan
is \emph{optimal}.
\end{claim}
\begin{proof} Suppose otherwise, then consider an optimal path $p^*$ with final state $f^*$
  must have been pruned. Let $n$ be the state along $p^*$ that
  was pruned, and let $m$ be a non-pruned state with $m \succ n$.
  Then, again from condition (2) and (3), there must be an analogous path
  starting from $m$ and running to a final state $f^\prime$. Moreover, by condition (1)
  we have that the total cost of this path $g(f^\prime) \le g(f^*)$, a contradiction.

  XXX We should say something ensuring that no states in $p^\prime$ are pruned.
\end{proof}



\begin{claim}{}\label{clm-optimally-efficient}
For any compatible partial order $\prec$, Skyplan is \emph{optimally efficient}.
\end{claim}
\begin{proof} XXX \end{proof}

\section{Inferring Partial Orders}

\newcommand{\po}{\preceq_R}

In this section, we show how to automatically infer a compatible partial order from a
planning problem definition. First, we'll describe a partial order for the simpler case of
domains without concurrency, and then we'll show how to extend the partial order algorithm
to accommodate the augmented state representation that is necessary to support concurrency.

When planning with resources, a planning state $n$ can be viewed as a mapping from resource
types to values. That is, for a given resource $r$, $n(r) \in \R$ is the quantity of that
resource available at state $n$.\footnote{Many planning state representations also require
some notion of boolean predicates, but in order to simplify the exposition, for the
purposes of defining a partial order we view these as special resources that always take
values in \{0, 1\}.}

If we want to determine whether a state $\mathbf{n}$ dominates $\mathbf{m}$, then we need
to know two things: first, does $\mathbf{n}$ have lower cost, and second, does $\mathbf{n}$
have a more ``useful'' set of resources? The first criterion is easy to check, but the
second requires some notion of what it means for resources to be useful or not.

There are basically two ways in which the value of a particular resource can matter: it can
either contribute to satisfying the goal test $n \in F$, or it can contribute to satisfying
the precondition of some action that might get us closer to the goal. In both cases, we're
concerned with the relationship between the value of a particular resource $r$, and a
particular boolean predicate $b$. In general, we want to know when it helps to have more (or less) of a particular resource, so we formalize the relationship with the following notions:
\begin{definition}[$r$-Dependent]
A predicate $b$ is $r-$\textit{dependent} if $\exists n, n'$ with $b(n) = \text{true}$ and $b(n') = \text{false}$, but where $n$ and $n'$ are identical except that $n(r) \ne n'(r)$.
\end{definition}
\begin{definition}[$r$-Positive]
	A predicate $b$ is $r-$\textit{positive} if $b$ is $r-$dependent and
	\begin{enumerate}
		\item $\forall n, n'$ identical except $n(r) < n'(r)$, $b(n) \Rightarrow b(n').$
		\item $\forall n, n'$ identical except $n(r) > n'(r)$, $\neg b(n) \Rightarrow \neg b(n')$
	\end{enumerate}
\end{definition}
\begin{definition}[$r$-Negative]
	A predicate $b$ is $r-$\textit{negative} if $b$ is $r-$dependent and
	\begin{enumerate}
		\item $\forall n, n'$ identical except $n(r) > n'(r)$, $b(n) \Rightarrow b(n').$
		\item $\forall n, n'$ identical except $n(r) < n'(r)$, $\neg b(n) \Rightarrow \neg b(n')$
	\end{enumerate}
\end{definition}
For example, the predicate ``$n(r) \ge 1$'' is $r-$positive, the predicate ``$n(r) \le 0$'' is $r-negative$, the predicate ``$n(r_1) \ge n(r_2)$'' is $r_1-$positive, but $r_2-$negative, and the predicate ``$1 \le n(r) \le 2$'' is $r-$dependent, but neither $r-$positive nor $r-$negative.

Using these definitions, we can construct a partial order based on three parts of the problem definition:
\begin{enumerate}
	\item The set of resources.\footnote{Many planning domains use first-order value functions and predicates. For these, each possible grounded instantiation is treated as a separate resource.}
	\item The set of possible actions, particularly their preconditions.\footnote{Again, for first-order actions, all possible groundings are considered separately.}
	\item The goal test: $n \in F$.
\end{enumerate}

Let $B$ be the set of all relevant predicates (the preconditions for each action, plus the goal test). Then we partition all the resources into four disjoint sets: $R^+$, $R^-$, $R^=$, and $R^\emptyset$, according to the following criteria:
\begin{itemize}
	\item $r \in R^+$ if $\forall b \in B, b$ is $r-$dependent implies that $b$ is $r-$positive, and $\exists$ at least one $b \in B$ that is $r-$positive.
	\item $r \in R^-$ if $\forall b \in B, b$ is $r-$dependent implies that $b$ is $r-$negative, and $\exists$ at least one $b \in B$ that is $r-$negative.
	\item $r \in R^=$ if $\exists b \in B$ that is $r-$dependent but not $r-$positive or $r-$negative, \emph{or} if $\exists b_1, b_2 \in B$ with $b_1$ $r-$positive and $b_2$ $r-$negative.
	\item $r \in R^\emptyset$ if $\forall b \in B, b$ is \emph{not} $r-$dependent.
\end{itemize}

Finally, we can define the partial order $\po$:
\begin{definition}[$\po$]
	\label{def-po}
	For planning states $\textbf{n} = (n, c)$ and $\textbf{m} = (m, d)$, we say that $\textbf{n} \po \textbf{m}$ if and only if:
	\begin{enumerate}
		\item $c \ge d$,
		\item $\forall r \in R^+, n(r) \le m(r)$,
		\item $\forall r \in R^-, n(r) \ge m(r)$, and
		\item $\forall r \in R^=, n(r) = m(r)$
	\end{enumerate}
\end{definition}

\begin{claim}{}{\label{clm-po-compatible}}
	If action costs and effects are deterministic (do not depend on the current state),\footnote{Note that if a domain does have context-dependent actions, and if the mapping from states to costs/effects is discrete, then each non-deterministic action can be replaced with a set of deterministic actions with varying preconditions.} then $\po$ is compatible.
\end{claim}
\begin{proof}
	Condition 1 of Definition~\ref{def-compatibility} follows directly from condition 1 of Definition~\ref{def-po}.
	
	To verify condition 3 of Definition~\ref{def-compatibility}, we only need to consider resources $r$ for which the goal test is $r-$dependent (changes in other resources will not affect the outcome of the test). If the goal test is $r-$positive, then $r \in R^+$ or $r \in R^=$, so $n(r) \le m(r)$. If the goal test is $r-$negative, then $r \in R^-$ or $r \in R^=$, so $n(r) \ge m(r)$. If the goal test is neither (but is $r-$dependent), then $r \in R^=$, so $n(r) = m(r)$. Taken together, these conditions ensure that $n \in F \Rightarrow m \in F$.
	
	Finally, to verify condition 2 of Definition~\ref{def-compatibility}, observe that some particular action results in the transition from $n$ to $n'$. By the argument above, if the precondition of this action holds for $n$, then it also holds for $m$. Let $m'$ be the result of taking this action from $m$. By assumption, the cost is identical, and also by assumption, the change in resources from $m$ to $m'$ is identical to that from $n$ to $n'$, which implies that $\forall r, m'(r) - n'(r) = m(r) - n(r)$. Therefore, $\textbf{n'} \po \textbf{m'}$.
\end{proof}

\section{Exploiting Heuristic Planners}

\section{Experiments}

\subsection{The StarCraft Domain}
\begin{figure}
  \caption{states pruned table?}
\end{figure}
\subsection{The Woodworking Domain}
\subsection{The StarCraft 2 Domain}
\begin{figure}
  \caption{Plan length over time? Anytime plan length over time?}
\end{figure}

XXX stuff about Starcraft 2 and Evo Chamber
XXX http://www.pcgamer.com/2010/11/02/computer-program-finds-devastating-starcraft-2-build-orders/

\section{Conclusion}

\bibliographystyle{aaai}
\bibliography{refs}

\end{document}
